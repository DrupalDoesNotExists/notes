---
title: "Cloudflare-like инфраструктура"
date: 2023-04-15T14:24:08+03:00
tags: ["IT", "Сети", "Cloudflare", "Firewall", "DDOS"]
draft: false
---

Вы вероятно слышали о Cloudflare, если когда-нибудь интересовались инфраструктурами, сетями и *DOS атаками. Недавно у меня возник практический интерес в понимании технологий и инфраструктуры, которые использует Cloudflare.

## L7 HTTP(S) трафик

Далеко не секрет, что для фильтрации L7 трафика Cloudflare использует DSR + обратное проксирование, перенаправляющее трафик на распределённое облако для анализа и применения firewall правил. Так же не трудно догадаться, что Cloudflare использует Machine Learning: защита способна отсекать даже 0-day атаки.

``Обратное проксирование (reverse proxy)`` - прокси находится не на стороне клиента, а на стороне сервера.

``DSR (Direct Server Response)`` - при проксировании, сервер отвечает напрямую клиенту, а не прокси. Это уменьшает пинг для исходящих пакетов. При этом, поле destination ip в TCP заголовках пакетов подменяется на IP прокси.

Стоит заметить, что в таком случае Cloudflare ``не выделяет вам личный адрес``. Вы просто ставите ``общий IP`` в A запись своего домена.

HTTP включает в себя заголовок Host, он содержит оригинальный домен. Это позволяет разруливать конечное назначение для пакетов в stateless режиме.

При этом, Cloudflare использует так называемую ``балансировку нагрузки без балансировщика`` или же модель BGP + anycast. Тот общий IP принадлежит не конкретной машине, а подсети и перенаправляет любые входящие соединения на ближайший свободный сервер (``anycast``). При этом используется протокол ``BGP`` (Border Gateway Protocol).

Простая текстовая схема выглядит примерно вот так:

```

Клиент  =('example.com')=>  DNS
        <=(Cloudflare)====  DNS
Клиент  =(HTTPS трафик)==>  Cloudflare--->  Фильтр 1  # не выбран
                            \------------>  Фильтр 2  # не выбран
                            \============>  Фильтр 3  =>  Сервер
Клиент  <=(HTTPS трафик, SRC=Cloudflare)================  Сервер

<===> : выбранный путь данных
<---> : возможный путь данных

```

## L3-L4 (TCP/UDP) трафик

Cloudflare предлагает услуги L3-L4 защиты под названием Magic Transit (``прим.: работает оно и вправду волшебно!``). Схема с фильтрацией по большей части остаётся той же. Изменяется лишь то, как трафик попадает на обработку в Cloudflare.

Для этого Cloudflare использует ``динамические IP`` и ``кастомный инстанс DNS``. После подключения Magic Transit вам выделяется временный адрес, который ассоциируется с вашим доменом. Вы прописываете запись типа NS для своего домена и указываете в ней DNS Cloudflare'а, после чего любые lookup-ы будут перенаправляться туда.

Эту необходимость диктует внутреннее устройство пакетов. Я не буду полностью рассматривать TCP/IP стек, хорошая статья есть на ``википедии``. Скажу лишь, что любой пакет состоит из пачки заголовков в соответствии с уровнями OSI и собственно полезных данных, за маршрутизацию отвечает ``Internet Protocol (IP)``. Если бы Magic Transit тоже использовал бы 1 общий адрес BGP + anycast подсети, то он бы просто не смог определить точку назначения: клиент знает только IP адрес подсети Cloudflare, а домен в IP не передаётся.

Примерная схема проблемы:
```

Клиент  =('example.com')=>  DNS
        <=(Cloudflare)====  DNS
Клиент  =(TCP, DST=Cloudflare)=>  Cloudflare---> Фильтр 1
                                  \============> Фильтр 2  # куда?
                                  \------------> Фильтр 3

<===> : выбранный путь данных
<---> : возможный путь данных

```

Схема работы Magic Transit:
```

Клиент  =('example.com')========>  DNS
        <=(NS: 'Cloudflare DNS')=  DNS
        =('example.com')========>  Cloudflare DNS
        <=(Cloudflare)===========  Cloudflare DNS

Клиент  =(TCP, DST=Cloudflare)=>  Cloudflare===>  Фильтр 1  => Сервер
                                  \------------>  Фильтр 2
                                  \------------>  Фильтр 3
Клиент  <=(TCP, SRC=Cloudflare)=================  Сервер

<===> : выбранный путь данных
<---> : возможный путь данных

```

## Фильтрация и анализ

Полное внутреннее устройство фильтров Cloudflare никто, конечно, не раскрывает. Но у меня есть предположения, которыми я здесь и поделюсь.

Трафик проходит через 3 основных стадии фильтрации (пользовательские правила не учитываются):
1. Статические правила и Firewall
2. Глобальная модель Cloudflare
3. Локальная модель (1 сеть = 1 модель)

Статические правила и Firewall нужны для отражения самых слабых и простейших DDOS атак, которые неэффективно отражать нейросетью. Они так же помогают модифицировать трафик так, чтобы сделать его полностью валидным, например сбросить ``PSH``, ``URG``, ``RST`` флаги в TCP пакете. Стоит заметить, что исходя из статей в блоге Cloudflare, стандартные iptables/ipset и пр. не удовлетворили их нужды, поэтому имплементация firewall'а у них своя. К ней так же написан кастомный трекинг соединений flowtrackd (замена conntrack), подробнее можно прочитать в статье от самого Cloudflare [здесь](https://blog.cloudflare.com/announcing-flowtrackd/). Для http/https вероятнее всего применяется дополнительная цепочка правил, которая в том числе учитывает ответы сервера.

Глобальная модель Cloudflare нужна для отражения более сложных атак, которые могут принимать разные формы и не могут быть полностью описаны статическим множеством правил, но при этом они не зависят от трафика конкретного клиента. Яркий пример: ``slowloris``.

И наконец локальная модель. Она нужна для отражения самых сложных видов атак, которые определяются только через аномалии в трафике. Модель обучается на легитимном входящем трафике к вашему серверу и позже отличает его от вредоносного.

```

Клиент  =(легитимный трафик)=>  Cloudflare  ->  {Firewall}
  ^^                                                ||
  ===================  Сервер  <-  {Local}  <-  {Machine Learning}

{XYZ} : стадия фильтрации
<---> : передача между стадиями
<===> : путь данных

```

## Заключение

Теперь вы знакомы с примерной инфраструктурой Cloudflare и можете поднять свой :).
